**设计同步器的意义**

多线程编程中，有可能会出现多个线程同时访问同一个共享、可变资源的情况，这个资源我们称之其为临界资源；这种资源可能是：对象、变量、文件等  

* 共享： 资源可以由多个线程同时访问  
* 可变：资源可以在其生命周期内被修改  

造成的问题：由于线程执行的过程是不可控的，所以需要采用同步机制来协同对对象可变状态的访问！  

**如何解决线程并发安全问题**

实际上，所有的并发模式在解决线程安全问题时，采用的方案都是**序列化访问临界资源**。即在同一时刻，只能有一个线程访问临界资源，也称作**同步互斥访问**。  

java提供了两种方式来实现同步互斥访问：synchronized 和 Lock  

* **同步器的本质就是加锁 **   
* **加锁目的：序列化访问临界资源**  同一时刻只能有一个线程访问临界资源(**同步互斥访问**)  
* 方法内部的局部变量并不是临界资源，因为这些局部变量是在每个线程的私有栈中，因此不具有共享性，不会导致线程安全问题  

**synchronized原理详解 **

synchronized内置锁是一种对象锁(锁的是对象而非引用)，作用粒度是对象，可以用来实现对临界资源的同步互斥访问，是可
重入的  

加锁的方式：

* 同步实例方法，锁是当前实例对象
* 同步类方法，锁是当前类对象
* 同步代码块，锁是括号里面的对象  

synchronized是基于JVM内置锁实现，通过内部对象Monitor(监视器锁)实现，基于进入与退出Monitor对象实现方法与代码块同步，监视器锁的实现依赖底层操作系统的Mutex lock（互斥锁）实现，它是一个重量级锁性能较低。当然，JVM内置锁在1.5之后版本做了重大的优化，如锁粗化（Lock Coarsening）、锁消除（Lock Elimination）、轻量级锁（Lightweight Locking）、  偏向锁（Biased Locking）、适应性自旋（Adaptive Spinning）等技术来减少锁操作的开销，，内置锁的并发性能已经基本与Lock持平。  

synchronized关键字被编译成字节码后会被翻译成monitorenter 和 monitorexit 两条指令分别在同步块逻辑代码的起始位置
与结束位置  

![image-20211114064952838](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211114064952838.png)

每个同步对象都有一个自己的Monitor(监视器锁)，加锁过程如下图所示：  

![image-20211114065032650](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211114065032650.png)



